diff --git a/node_modules/@actions/cache/lib/cache.d.ts b/node_modules/@actions/cache/lib/cache.d.ts
index 4658366..af678e8 100644
--- a/node_modules/@actions/cache/lib/cache.d.ts
+++ b/node_modules/@actions/cache/lib/cache.d.ts
@@ -21,7 +21,7 @@ export declare function isFeatureAvailable(): boolean;
  * @param enableCrossOsArchive an optional boolean enabled to restore on windows any cache created on any platform
  * @returns string returns the key for the cache hit, otherwise returns undefined
  */
-export declare function restoreCache(paths: string[], primaryKey: string, restoreKeys?: string[], options?: DownloadOptions, enableCrossOsArchive?: boolean): Promise<string | undefined>;
+export declare function restoreCache(paths: string[], primaryKey: string, restoreKeys?: string[], options?: DownloadOptions, enableCrossOsArchive?: boolean): Promise<CacheEntry | undefined>;
 /**
  * Saves a list of files with the specified key
  *
@@ -31,4 +31,12 @@ export declare function restoreCache(paths: string[], primaryKey: string, restor
  * @param options cache upload options
  * @returns number returns cacheId if the cache was saved successfully and throws an error if save fails
  */
-export declare function saveCache(paths: string[], key: string, options?: UploadOptions, enableCrossOsArchive?: boolean): Promise<number>;
+export declare function saveCache(paths: string[], key: string, options?: UploadOptions, enableCrossOsArchive?: boolean): Promise<CacheEntry>;
+
+// PATCHED: Add `CacheEntry` as return type for save/restore functions
+// This allows us to track and report on cache entry sizes.
+export declare class CacheEntry {
+    key: string;
+    size?: number;
+    constructor(key: string, size?: number);
+}
\ No newline at end of file
diff --git a/node_modules/@actions/cache/lib/cache.js b/node_modules/@actions/cache/lib/cache.js
index 3fc8bd1..235cbfe 100644
--- a/node_modules/@actions/cache/lib/cache.js
+++ b/node_modules/@actions/cache/lib/cache.js
@@ -1,18 +1,18 @@
 "use strict";
-var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
     if (k2 === undefined) k2 = k;
     var desc = Object.getOwnPropertyDescriptor(m, k);
     if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
-      desc = { enumerable: true, get: function() { return m[k]; } };
+        desc = { enumerable: true, get: function () { return m[k]; } };
     }
     Object.defineProperty(o, k2, desc);
-}) : (function(o, m, k, k2) {
+}) : (function (o, m, k, k2) {
     if (k2 === undefined) k2 = k;
     o[k2] = m[k];
 }));
-var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
     Object.defineProperty(o, "default", { enumerable: true, value: v });
-}) : function(o, v) {
+}) : function (o, v) {
     o["default"] = v;
 });
 var __importStar = (this && this.__importStar) || function (mod) {
@@ -150,24 +150,26 @@ function restoreCache(paths, primaryKey, restoreKeys, options, enableCrossOsArch
             core.info(`Cache Size: ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B)`);
             yield (0, tar_1.extractTar)(archivePath, compressionMethod);
             core.info('Cache restored successfully');
-            return cacheEntry.cacheKey;
-        }
-        catch (error) {
-            const typedError = error;
-            if (typedError.name === ValidationError.name) {
-                throw error;
-            }
-            else {
-                // Supress all non-validation cache related errors because caching should be optional
-                if (error.message.includes(`Cache service responded with 404`)) {
-                    core.info(`Did not get a cache hit; proceeding as an uncached run`);
-                }
-                else {
-                    core.warning(`Failed to restore: ${error.message}`);
-                    yield reportFailure();
-                }
-            }
+            // PATCHED - Return more inforamtion about restored entry
+            return new CacheEntry(cacheEntry.cacheKey, archiveFileSize);;
         }
+        // PATCHED - propagate errors
+        // catch (error) {
+        //     const typedError = error;
+        //     if (typedError.name === ValidationError.name) {
+        //         throw error;
+        //     }
+        //     else {
+        //         // Supress all non-validation cache related errors because caching should be optional
+        //         if (error.message.includes(`Cache service responded with 404`)) {
+        //             core.info(`Did not get a cache hit; proceeding as an uncached run`);
+        //         }
+        //         else {
+        //             core.warning(`Failed to restore: ${error.message}`);
+        //             yield reportFailure();
+        //         }
+        //     }
+        // }
         finally {
             // Try to delete the archive to save space
             try {
@@ -258,20 +260,23 @@ function saveCache(paths, key, options, enableCrossOsArchive = false) {
             }
             core.debug(`Saving Cache (ID: ${cacheId})`);
             yield cacheHttpClient.saveCache(cacheId, archivePath, (_g = (_f = reserveCacheResponse.result) === null || _f === void 0 ? void 0 : _f.uploadUrls) !== null && _g !== void 0 ? _g : [], (_j = (_h = reserveCacheResponse.result) === null || _h === void 0 ? void 0 : _h.uploadId) !== null && _j !== void 0 ? _j : '');
+
+            // PATCHED - Return more inforamtion about saved entry
+            return new CacheEntry(key, archiveFileSize);
         }
-        catch (error) {
-            const typedError = error;
-            if (typedError.name === ValidationError.name) {
-                throw error;
-            }
-            else if (typedError.name === ReserveCacheError.name) {
-                core.info(`Failed to save: ${typedError.message}`);
-                core.debug(JSON.stringify(error));
-            }
-            else {
-                core.warning(`Failed to save: ${typedError.message}`);
-            }
-        }
+        // catch (error) {
+        //     const typedError = error;
+        //     if (typedError.name === ValidationError.name) {
+        //         throw error;
+        //     }
+        //     else if (typedError.name === ReserveCacheError.name) {
+        //         core.info(`Failed to save: ${typedError.message}`);
+        //         core.debug(JSON.stringify(error));
+        //     }
+        //     else {
+        //         core.warning(`Failed to save: ${typedError.message}`);
+        //     }
+        // }
         finally {
             // Try to delete the archive to save space
             try {
@@ -285,4 +290,11 @@ function saveCache(paths, key, options, enableCrossOsArchive = false) {
     });
 }
 exports.saveCache = saveCache;
+class CacheEntry {
+    constructor(key, size) {
+        this.key = key;
+        this.size = size;
+    }
+}
+exports.CacheEntry = CacheEntry;
 //# sourceMappingURL=cache.js.map
\ No newline at end of file
